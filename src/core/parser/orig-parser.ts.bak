import { Token, Tokenizer, TokenType, Keyword } from './tokenizer'
import type {
  ASTNode,
  Program,
  Statement,
  Expression,
  Pattern,
  ImportDeclaration,
  ExportNamedDeclaration,
  ExportDefaultDeclaration,
  ExportAllDeclaration,
  ImportSpecifier,
  ExportSpecifier,
  Identifier,
  Literal,
  BinaryExpression,
  UnaryExpression,
  CallExpression,
  MemberExpression,
  NewExpression,
  ArrayExpression,
  ObjectExpression,
  ArrowFunctionExpression,
  AssignmentExpression,
  ConditionalExpression,
  LogicalExpression,
  VariableDeclaration,
  VariableDeclarator,
  FunctionDeclaration,
  ReturnStatement,
  IfStatement,
  ForStatement,
  WhileStatement,
  ExpressionStatement,
  BlockStatement,
  SpreadElement,
  Property,
  ArrayPattern,
  ObjectPattern,
} from './ast'
import { NodeType } from './ast'

export class Parser {
  private tokens: Token[] = []
  private pos = 0

  parse(code: string): Program {
    const tokenizer = new Tokenizer(code)
    this.tokens = tokenizer.tokenize()
    this.pos = 0

    const body: Statement[] = []

    while (this.peek().type !== TokenType.EOF) {
      body.push(this.parseStatement())
    }

    return {
      type: NodeType.PROGRAM,
      body,
    }
  }

  private peek(): Token {
    return this.tokens[this.pos] || { type: TokenType.EOF, value: '', loc: { line: 0, column: 0 } }
  }

  private eat(type: TokenType, value?: string): Token {
    const token = this.peek()

    if (token.type !== type) {
      throw new Error(`Expected ${type}, got ${token.type}`)
    }

    if (value !== undefined && token.value !== value) {
      throw new Error(`Expected ${value}, got ${token.value}`)
    }

    this.pos++
    return token
  }

  private match(type: TokenType, value?: string): boolean {
    const token = this.peek()
    if (value !== undefined) {
      return token.type === type && token.value === value
    }
    return token.type === type
  }

  private parseStatement(): Statement {
    const token = this.peek()

    if (token.type === TokenType.KEYWORD) {
      switch (token.value) {
        case Keyword.IMPORT:
          return this.parseImportDeclaration()
        case Keyword.EXPORT:
          return this.parseExportDeclaration()
        case Keyword.CONST:
        case Keyword.LET:
        case Keyword.VAR:
          return this.parseVariableDeclaration()
        case Keyword.FUNCTION:
          return this.parseFunctionDeclaration()
        case Keyword.CLASS:
          return this.parseClassDeclaration()
        case Keyword.RETURN:
          return this.parseReturnStatement()
        case Keyword.IF:
          return this.parseIfStatement()
        case Keyword.FOR:
          return this.parseForStatement()
        case Keyword.WHILE:
          return this.parseWhileStatement()
        default:
          return this.parseExpressionStatement()
      }
    }

    return this.parseExpressionStatement()
  }

  private parseImportDeclaration(): ImportDeclaration {
    this.eat(TokenType.KEYWORD, Keyword.IMPORT)

    const specifiers: ImportSpecifier[] = []

    if (this.match(TokenType.PUNCTUATOR, '{')) {
      this.eat(TokenType.PUNCTUATOR, '{')

      if (!this.match(TokenType.PUNCTUATOR, '}')) {
        do {
          specifiers.push(this.parseImportSpecifier())
        } while (this.match(TokenType.PUNCTUATOR, ',') && this.eat(TokenType.PUNCTUATOR, ','))
      }

      this.eat(TokenType.PUNCTUATOR, '}')
    } else if (this.match(TokenType.OPERATOR, '*')) {
      this.eat(TokenType.OPERATOR, '*')
      const local = this.parseIdentifier()
      specifiers.push({
        type: 'ImportNamespaceSpecifier',
        local,
      })
    } else if (this.match(TokenType.IDENTIFIER) || this.match(TokenType.KEYWORD, Keyword.DEFAULT)) {
      const local = this.parseIdentifier()
      specifiers.push({
        type: 'ImportDefaultSpecifier',
        local,
      })

      if (this.match(TokenType.PUNCTUATOR, ',')) {
        this.eat(TokenType.PUNCTUATOR, ',')
        if (this.match(TokenType.PUNCTUATOR, '{')) {
          this.eat(TokenType.PUNCTUATOR, '{')

          if (!this.match(TokenType.PUNCTUATOR, '}')) {
            do {
              specifiers.push(this.parseImportSpecifier())
            } while (this.match(TokenType.PUNCTUATOR, ',') && this.eat(TokenType.PUNCTUATOR, ','))
          }

          this.eat(TokenType.PUNCTUATOR, '}')
        }
      }
    }

    this.eat(TokenType.KEYWORD, Keyword.FROM)
    const sourceToken = this.eat(TokenType.STRING)
    const source = sourceToken.value

    return {
      type: NodeType.IMPORT_DECLARATION,
      specifiers,
      source,
    }
  }

  private parseImportSpecifier(): ImportSpecifier {
    const local = this.parseIdentifier()

    if (this.match(TokenType.KEYWORD, Keyword.AS)) {
      this.eat(TokenType.KEYWORD, Keyword.AS)
      const imported = this.parseIdentifier()
      return {
        type: 'ImportSpecifier',
        local: imported,
        imported: local,
      }
    }

    return {
      type: 'ImportSpecifier',
      local,
    }
  }

  private parseExportDeclaration(): ExportNamedDeclaration | ExportDefaultDeclaration | ExportAllDeclaration {
    this.eat(TokenType.KEYWORD, Keyword.EXPORT)

    if (this.match(TokenType.OPERATOR, '*')) {
      this.eat(TokenType.OPERATOR, '*')
      let exported: Identifier | undefined

      if (this.match(TokenType.KEYWORD, Keyword.AS)) {
        this.eat(TokenType.KEYWORD, Keyword.AS)
        exported = this.parseIdentifier()
      }

      this.eat(TokenType.KEYWORD, Keyword.FROM)
      const sourceToken = this.eat(TokenType.STRING)
      const source = sourceToken.value

      return {
        type: NodeType.EXPORT_ALL_DECLARATION,
        source,
        exported: exported?.name,
      }
    }

    if (this.match(TokenType.KEYWORD, Keyword.DEFAULT)) {
      this.eat(TokenType.KEYWORD, Keyword.DEFAULT)
      const declaration = this.parseExpression()

      return {
        type: NodeType.EXPORT_DEFAULT_DECLARATION,
        declaration,
      }
    }

    const specifiers: ExportSpecifier[] = []

    if (this.match(TokenType.PUNCTUATOR, '{')) {
      this.eat(TokenType.PUNCTUATOR, '{')

      if (!this.match(TokenType.PUNCTUATOR, '}')) {
        do {
          specifiers.push(this.parseExportSpecifier())
        } while (this.match(TokenType.PUNCTUATOR, ',') && this.eat(TokenType.PUNCTUATOR, ','))
      }

      this.eat(TokenType.PUNCTUATOR, '}')
    }

    let source: string | undefined
    let declaration: Statement | undefined

    if (this.match(TokenType.KEYWORD, Keyword.FROM)) {
      this.eat(TokenType.KEYWORD, Keyword.FROM)
      const sourceToken = this.eat(TokenType.STRING)
      source = sourceToken.value
    } else {
      declaration = this.parseStatement()
    }

    return {
      type: NodeType.EXPORT_NAMED_DECLARATION,
      specifiers,
      source,
      declaration,
    }
  }

  private parseExportSpecifier(): ExportSpecifier {
    const local = this.parseIdentifier()

    if (this.match(TokenType.KEYWORD, Keyword.AS)) {
      this.eat(TokenType.KEYWORD, Keyword.AS)
      const exported = this.parseIdentifier()
      return { local, exported }
    }

    return { local, exported: local }
  }

  private parseVariableDeclaration(): VariableDeclaration {
    const kindToken = this.eat(TokenType.KEYWORD)
    const kind = kindToken.value as 'const' | 'let' | 'var'

    const declarations: VariableDeclarator[] = []

    do {
      declarations.push(this.parseVariableDeclarator())
    } while (this.match(TokenType.PUNCTUATOR, ',') && this.eat(TokenType.PUNCTUATOR, ','))

    return {
      type: NodeType.VARIABLE_DECLARATION,
      kind,
      declarations,
    }
  }

  private parseVariableDeclarator(): VariableDeclarator {
    const id = this.parsePattern()
    let init: Expression | undefined

    if (this.match(TokenType.OPERATOR, '=')) {
      this.eat(TokenType.OPERATOR, '=')
      init = this.parseExpression()
    }

    return {
      type: NodeType.VARIABLE_DECLARATOR,
      id,
      init,
    }
  }

  private parseFunctionDeclaration(): FunctionDeclaration {
    const async = this.match(TokenType.KEYWORD, Keyword.ASYNC)
    if (async) {
      this.eat(TokenType.KEYWORD, Keyword.ASYNC)
    }

    this.eat(TokenType.KEYWORD, Keyword.FUNCTION)
    const generator = this.match(TokenType.OPERATOR, '*')
    if (generator) {
      this.eat(TokenType.OPERATOR, '*')
    }

    let id: Identifier | undefined
    if (this.match(TokenType.IDENTIFIER)) {
      id = this.parseIdentifier()
    }

    this.eat(TokenType.PUNCTUATOR, '(')
    const params: Pattern[] = []

    if (!this.match(TokenType.PUNCTUATOR, ')')) {
      do {
        params.push(this.parsePattern())
      } while (this.match(TokenType.PUNCTUATOR, ',') && this.eat(TokenType.PUNCTUATOR, ','))
    }

    this.eat(TokenType.PUNCTUATOR, ')')
    const body = this.parseBlockStatement()

    return {
      type: NodeType.FUNCTION_DECLARATION,
      id,
      params,
      body,
      async,
      generator,
    }
  }

  private parseClassDeclaration(): Statement {
    this.eat(TokenType.KEYWORD, Keyword.CLASS)
    let id: Identifier | undefined

    if (this.match(TokenType.IDENTIFIER)) {
      id = this.parseIdentifier()
    }

    let superClass: Expression | undefined

    if (this.match(TokenType.KEYWORD, Keyword.EXTENDS)) {
      this.eat(TokenType.KEYWORD, Keyword.EXTENDS)
      superClass = this.parseExpression()
    }

    this.eat(TokenType.PUNCTUATOR, '{')
    this.eat(TokenType.PUNCTUATOR, '}')

    return {
      type: NodeType.CLASS_DECLARATION,
      id,
      superClass,
      body: { type: 'ClassBody', body: [] },
    }
  }

  private parseReturnStatement(): ReturnStatement {
    this.eat(TokenType.KEYWORD, Keyword.RETURN)
    let argument: Expression | undefined

    if (!this.match(TokenType.PUNCTUATOR, ';') && this.peek().type !== TokenType.EOF) {
      argument = this.parseExpression()
    }

    if (this.match(TokenType.PUNCTUATOR, ';')) {
      this.eat(TokenType.PUNCTUATOR, ';')
    }

    return {
      type: NodeType.RETURN_STATEMENT,
      argument,
    }
  }

  private parseIfStatement(): IfStatement {
    this.eat(TokenType.KEYWORD, Keyword.IF)
    this.eat(TokenType.PUNCTUATOR, '(')
    const test = this.parseExpression()
    this.eat(TokenType.PUNCTUATOR, ')')
    const consequent = this.parseStatement()

    let alternate: Statement | undefined

    if (this.match(TokenType.KEYWORD, Keyword.ELSE)) {
      this.eat(TokenType.KEYWORD, Keyword.ELSE)
      alternate = this.parseStatement()
    }

    return {
      type: NodeType.IF_STATEMENT,
      test,
      consequent,
      alternate,
    }
  }

  private parseForStatement(): ForStatement {
    this.eat(TokenType.KEYWORD, Keyword.FOR)
    this.eat(TokenType.PUNCTUATOR, '(')

    let init: VariableDeclaration | Expression | undefined

    if (this.match(TokenType.KEYWORD, Keyword.CONST) || this.match(TokenType.KEYWORD, Keyword.LET) || this.match(TokenType.KEYWORD, Keyword.VAR)) {
      init = this.parseVariableDeclaration()
    } else if (!this.match(TokenType.PUNCTUATOR, ';')) {
      init = this.parseExpression()
    }

    this.eat(TokenType.PUNCTUATOR, ';')
    const test = this.match(TokenType.PUNCTUATOR, ';') ? undefined : this.parseExpression()
    this.eat(TokenType.PUNCTUATOR, ';')
    const update = this.match(TokenType.PUNCTUATOR, ')') ? undefined : this.parseExpression()
    this.eat(TokenType.PUNCTUATOR, ')')

    const body = this.parseStatement()

    return {
      type: NodeType.FOR_STATEMENT,
      init,
      test,
      update,
      body,
    }
  }

  private parseWhileStatement(): WhileStatement {
    this.eat(TokenType.KEYWORD, Keyword.WHILE)
    this.eat(TokenType.PUNCTUATOR, '(')
    const test = this.parseExpression()
    this.eat(TokenType.PUNCTUATOR, ')')
    const body = this.parseStatement()

    return {
      type: NodeType.WHILE_STATEMENT,
      test,
      body,
    }
  }

  private parseExpressionStatement(): ExpressionStatement {
    const expression = this.parseExpression()

    if (this.match(TokenType.PUNCTUATOR, ';')) {
      this.eat(TokenType.PUNCTUATOR, ';')
    }

    return {
      type: NodeType.EXPRESSION_STATEMENT,
      expression,
    }
  }

  private parseExpression(): Expression {
    return this.parseAssignmentExpression()
  }

  private parseAssignmentExpression(): Expression {
    const left = this.parseLogicalExpression()

    if (this.match(TokenType.OPERATOR, '=') || this.match(TokenType.OPERATOR, '+=') || this.match(TokenType.OPERATOR, '-=')) {
      const operator = this.eat(TokenType.OPERATOR).value
      const right = this.parseAssignmentExpression()

      return {
        type: NodeType.ASSIGNMENT_EXPRESSION,
        operator,
        left: left as Pattern | MemberExpression,
        right,
      }
    }

    return left
  }

  private parseLogicalExpression(): Expression {
    let left = this.parseConditionalExpression()

    while (this.match(TokenType.OPERATOR, '&&') || this.match(TokenType.OPERATOR, '||')) {
      const operator = this.eat(TokenType.OPERATOR).value as '&&' | '||'
      const right = this.parseConditionalExpression()

      left = {
        type: NodeType.LOGICAL_EXPRESSION,
        operator,
        left,
        right,
      }
    }

    return left
  }

  private parseConditionalExpression(): Expression {
    const test = this.parseBinaryExpression()

    if (this.match(TokenType.OPERATOR, '?')) {
      this.eat(TokenType.OPERATOR, '?')
      const consequent = this.parseExpression()
      this.eat(TokenType.PUNCTUATOR, ':')
      const alternate = this.parseExpression()

      return {
        type: NodeType.CONDITIONAL_EXPRESSION,
        test,
        consequent,
        alternate,
      }
    }

    return test
  }

  private parseBinaryExpression(): Expression {
    let left = this.parseUnaryExpression()

    while (
      this.match(TokenType.OPERATOR, '+') ||
      this.match(TokenType.OPERATOR, '-') ||
      this.match(TokenType.OPERATOR, '*') ||
      this.match(TokenType.OPERATOR, '/') ||
      this.match(TokenType.OPERATOR, '%') ||
      this.match(TokenType.OPERATOR, '==') ||
      this.match(TokenType.OPERATOR, '===') ||
      this.match(TokenType.OPERATOR, '!=') ||
      this.match(TokenType.OPERATOR, '!==') ||
      this.match(TokenType.OPERATOR, '<') ||
      this.match(TokenType.OPERATOR, '<=') ||
      this.match(TokenType.OPERATOR, '>') ||
      this.match(TokenType.OPERATOR, '>=')
    ) {
      const operator = this.eat(TokenType.OPERATOR).value
      const right = this.parseUnaryExpression()

      left = {
        type: NodeType.BINARY_EXPRESSION,
        operator,
        left,
        right,
      }
    }

    return left
  }

  private parseUnaryExpression(): Expression {
    if (this.match(TokenType.OPERATOR, '!') || this.match(TokenType.OPERATOR, '-') || this.match(TokenType.OPERATOR, '+') || this.match(TokenType.OPERATOR, 'typeof')) {
      const operator = this.eat(TokenType.OPERATOR).value
      const argument = this.parseUnaryExpression()

      return {
        type: NodeType.UNARY_EXPRESSION,
        operator,
        prefix: true,
        argument,
      }
    }

    if (this.match(TokenType.OPERATOR, '++') || this.match(TokenType.OPERATOR, '--')) {
      const operator = this.eat(TokenType.OPERATOR).value
      const argument = this.parseUnaryExpression()

      return {
        type: NodeType.UNARY_EXPRESSION,
        operator,
        prefix: true,
        argument,
      }
    }

    return this.parseUpdateExpression()
  }

  private parseUpdateExpression(): Expression {
    const token = this.peek()

    if (this.match(TokenType.OPERATOR, '++') || this.match(TokenType.OPERATOR, '--')) {
      const operator = this.eat(TokenType.OPERATOR).value
      const argument = this.parseUnaryExpression()

      return {
        type: NodeType.UNARY_EXPRESSION,
        operator,
        prefix: true,
        argument,
      }
    }

    const expression = this.parseLeftHandSideExpression()

    if (this.match(TokenType.OPERATOR, '++') || this.match(TokenType.OPERATOR, '--')) {
      const operator = this.eat(TokenType.OPERATOR).value

      return {
        type: NodeType.UNARY_EXPRESSION,
        operator,
        prefix: false,
        argument: expression,
      }
    }

    return expression
  }

  private parseLeftHandSideExpression(): Expression {
    let expression = this.parsePrimaryExpression()

    while (true) {
      if (this.match(TokenType.PUNCTUATOR, '(')) {
        expression = this.parseCallExpression(expression)
      } else if (this.match(TokenType.PUNCTUATOR, '[')) {
        expression = this.parseMemberExpression(expression, true)
      } else if (this.match(TokenType.PUNCTUATOR, '.')) {
        expression = this.parseMemberExpression(expression, false)
      } else {
        break
      }
    }

    return expression
  }

  private parseCallExpression(callee: Expression): CallExpression {
    this.eat(TokenType.PUNCTUATOR, '(')
    const args: (Expression | SpreadElement)[] = []

    if (!this.match(TokenType.PUNCTUATOR, ')')) {
      do {
        if (this.match(TokenType.OPERATOR, '...')) {
          this.eat(TokenType.OPERATOR, '...')
          const argument = this.parseExpression()
          args.push({ type: NodeType.SPREAD_ELEMENT, argument })
        } else {
          args.push(this.parseExpression())
        }
      } while (this.match(TokenType.PUNCTUATOR, ',') && this.eat(TokenType.PUNCTUATOR, ','))
    }

    this.eat(TokenType.PUNCTUATOR, ')')

    return {
      type: NodeType.CALL_EXPRESSION,
      callee,
      arguments: args,
    }
  }

  private parseMemberExpression(object: Expression, computed: boolean): MemberExpression {
    if (computed) {
      this.eat(TokenType.PUNCTUATOR, '[')
      const property = this.parseExpression()
      this.eat(TokenType.PUNCTUATOR, ']')
    } else {
      this.eat(TokenType.PUNCTUATOR, '.')
    }

    const property = computed ? this.parseExpression() : this.parseIdentifier()

    return {
      type: NodeType.MEMBER_EXPRESSION,
      object,
      property,
      computed,
    }
  }

  private parsePrimaryExpression(): Expression {
    if (this.match(TokenType.IDENTIFIER)) {
      return this.parseIdentifier()
    }

    if (this.match(TokenType.NUMBER) || this.match(TokenType.STRING) || this.match(TokenType.KEYWORD, Keyword.TRUE) || this.match(TokenType.KEYWORD, Keyword.FALSE) || this.match(TokenType.KEYWORD, Keyword.NULL)) {
      return this.parseLiteral()
    }

    if (this.match(TokenType.PUNCTUATOR, '(')) {
      return this.parseGroupExpression()
    }

    if (this.match(TokenType.PUNCTUATOR, '{')) {
      return this.parseObjectExpression()
    }

    if (this.match(TokenType.PUNCTUATOR, '[')) {
      return this.parseArrayExpression()
    }

    throw new Error(`Unexpected token: ${this.peek().value}`)
  }

  private parseIdentifier(): Identifier {
    const token = this.eat(TokenType.IDENTIFIER)
    return {
      type: NodeType.IDENTIFIER,
      name: token.value,
    }
  }

  private parseLiteral(): Literal {
    const token = this.eat(TokenType.NUMBER, TokenType.STRING)

    let value: string | number | boolean | null

    if (token.type === TokenType.NUMBER) {
      value = Number(token.value)
    } else if (token.value === 'true') {
      value = true
    } else if (token.value === 'false') {
      value = false
    } else if (token.value === 'null') {
      value = null
    } else {
      value = token.value
    }

    return {
      type: NodeType.LITERAL,
      value,
    }
  }

  private parseGroupExpression(): Expression {
    this.eat(TokenType.PUNCTUATOR, '(')
    const expression = this.parseExpression()
    this.eat(TokenType.PUNCTUATOR, ')')
    return expression
  }

  private parseObjectExpression(): ObjectExpression {
    this.eat(TokenType.PUNCTUATOR, '{')
    const properties: Property[] = []

    if (!this.match(TokenType.PUNCTUATOR, '}')) {
      do {
        properties.push(this.parseProperty())
      } while (this.match(TokenType.PUNCTUATOR, ',') && this.eat(TokenType.PUNCTUATOR, ','))
    }

    this.eat(TokenType.PUNCTUATOR, '}')

    return {
      type: NodeType.OBJECT_EXPRESSION,
      properties,
    }
  }

  private parseProperty(): Property {
    const key = this.parseExpression()
    let value: Expression

    if (this.match(TokenType.PUNCTUATOR, ':')) {
      this.eat(TokenType.PUNCTUATOR, ':')
      value = this.parseExpression()
    } else {
      value = key
    }

    return {
      type: 'Property',
      key,
      value,
      kind: 'init',
      shorthand: key.type === NodeType.IDENTIFIER && (value as Identifier).name === (key as Identifier).name,
      computed: false,
    }
  }

  private parseArrayExpression(): ArrayExpression {
    this.eat(TokenType.PUNCTUATOR, '[')
    const elements: (Expression | null | SpreadElement)[] = []

    if (!this.match(TokenType.PUNCTUATOR, ']')) {
      do {
        if (this.match(TokenType.PUNCTUATOR, ',') && this.peek().value === ',') {
          elements.push(null)
          this.eat(TokenType.PUNCTUATOR, ',')
        } else if (this.match(TokenType.OPERATOR, '...')) {
          this.eat(TokenType.OPERATOR, '...')
          const argument = this.parseExpression()
          elements.push({ type: NodeType.SPREAD_ELEMENT, argument })
        } else {
          elements.push(this.parseExpression())
          if (this.match(TokenType.PUNCTUATOR, ',')) {
            this.eat(TokenType.PUNCTUATOR, ',')
          }
        }
      } while (this.pos < this.tokens.length && !this.match(TokenType.PUNCTUATOR, ']'))
    }

    this.eat(TokenType.PUNCTUATOR, ']')

    return {
      type: NodeType.ARRAY_EXPRESSION,
      elements,
    }
  }

  private parseBlockStatement(): BlockStatement {
    this.eat(TokenType.PUNCTUATOR, '{')
    const body: Statement[] = []

    while (!this.match(TokenType.PUNCTUATOR, '}')) {
      body.push(this.parseStatement())
    }

    this.eat(TokenType.PUNCTUATOR, '}')

    return {
      type: 'BlockStatement',
      body,
    }
  }

  private parsePattern(): Pattern {
    if (this.match(TokenType.PUNCTUATOR, '{')) {
      return this.parseObjectPattern()
    }

    if (this.match(TokenType.PUNCTUATOR, '[')) {
      return this.parseArrayPattern()
    }

    return this.parseIdentifier()
  }

  private parseObjectPattern(): ObjectPattern {
    this.eat(TokenType.PUNCTUATOR, '{')
    const properties: Property[] = []

    if (!this.match(TokenType.PUNCTUATOR, '}')) {
      do {
        const key = this.parseIdentifier()
        let value: Expression

        if (this.match(TokenType.PUNCTUATOR, ':')) {
          this.eat(TokenType.PUNCTUATOR, ':')
          value = this.parsePattern()
        } else {
          value = key
        }

        properties.push({
          type: 'Property',
          key,
          value,
          kind: 'init',
          shorthand: (value as Identifier).name === key.name,
          computed: false,
        })
      } while (this.match(TokenType.PUNCTUATOR, ',') && this.eat(TokenType.PUNCTUATOR, ','))
    }

    this.eat(TokenType.PUNCTUATOR, '}')

    return {
      type: 'ObjectPattern',
      properties,
    }
  }

  private parseArrayPattern(): ArrayPattern {
    this.eat(TokenType.PUNCTUATOR, '[')
    const elements: (Pattern | null)[] = []

    if (!this.match(TokenType.PUNCTUATOR, ']')) {
      do {
        if (this.match(TokenType.PUNCTUATOR, ',')) {
          elements.push(null)
          this.eat(TokenType.PUNCTUATOR, ',')
        } else {
          elements.push(this.parsePattern())
          if (this.match(TokenType.PUNCTUATOR, ',')) {
            this.eat(TokenType.PUNCTUATOR, ',')
          }
        }
      } while (!this.match(TokenType.PUNCTUATOR, ']'))
    }

    this.eat(TokenType.PUNCTUATOR, ']')

    return {
      type: 'ArrayPattern',
      elements,
    }
  }
}
